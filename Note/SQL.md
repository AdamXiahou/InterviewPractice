# 1. 常见的数据结构
### 栈(Stack)
先进后出，后进先出         
Go - 用数组实现栈       
//定义一个新的类型来表达栈，需要一个数组和一个指向最后一个元素的索引       
type stack struct {       
	i int       
	data [10]int       
}       
//注意，Go的数据传递中，是值传递,但是这样不能满足我们的预期。因为一个副本被创建并传递给函数，push和pop处理的都是副本。所以提供指针       
func (s *stack) push(k int) {       
	if s.i +1 > 10 {       
		fmt.Println("I'm full")       
		return       
	}       
	s.data[s.i] = k       
	s.i++       
}       
func (s *stack) pop() int{       
	if s.i -1 < 0 {       
		fmt.Println("I'm hungry")       
		return 0       
	}       
        
	s.i--       
	result := s.data[s.i]       
	s.data[s.i] = 0       
	return result       
}       
### 队列(Queue)
先进先出的一种特殊的线性链表     
### 数组(Array)
查询速度快： 通过地址值与索引可快速定位到数据      
删除效率低： 删除数据后要将每个数据前移     
添加效率极低： 添加位置后每个数据都后移，再添加数据     
### 链表
链表中的数据都是游离存储的，每个元素节点包含元素值与下一元素的地址     
查询速度慢，因为每次查询都要通过head指针依次查询     
添加，删除效率相对较高，因为只需要将指针重新指向新添加进来的元素，其他元素的位置不需要动     
### 二叉树
全名二叉搜索树。存入的数据以第一条数据为基准，小于放左，大于放右     
特点：     
1. 只能有一个根节点，每个节点最多支持两个直接子节点     
2. 节点的度： 节点拥有的子树的个数。节点的度数不大于2，如果度数为0，则称不叶子节点或者终端节点     
缺点：     
虽然二叉树容易提高一些效率，但是面对节点多时，或者树的深度很高时，还是会面临着查找速度慢的情况，而且还很容易出现退化链表的情况（存放数据是有序的时候）。    
### 平衡二叉树 AVL Tree
平衡二叉树是在满足二叉树的情况下，尽可能的让树的度数变低，以提高查询效率     
要求： 任意节点的两个左右子树高度差不超过1，任意节点的左右子树都是一个平衡二叉树     
在底层二叉树的基础上，对进行插入和删除操作时通过特定的操作（如**左旋转和右旋转等**）保持二叉查找树的平衡，从而获得较高查找性能。     
左旋转： 被旋转的节点从左侧上升到父节点     
右旋转： 被旋转的节点从右侧上升到父节点     
https://www.cs.usfca.edu/~galles/visualization/AVLtree.html     
缺点：     
1. 树的深度过高，还是查询慢     
2. 无法解决回旋查找（批量查找）问题     
3. 添加节点效率过低，因为节点旋转有可能会牵一发而动全身     
### 红黑树
自平衡二叉查找树     
每一个节点或者是红色的或者是黑色的，根节点必须是黑色的     
如果某一个节点是红色的，那么它的子节点必须是黑色的（不能出现两个红色项相连情况）     
对每一个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数目的黑色节点     
如果一个节点没有子节点或者父节点，则该节点的相应指针属性值为Null,这些Null视为叶节点，叶节点是黑色     
添加节点：     
添加节点的颜色可以是红色也可以是黑色     
默认使用红色效率高     
**红黑树增删改查效率都比较好**
相对于要求严格的AVL树来说，旋转次数变少，所以对于搜索，插入删除操作多的请况下使用红黑树
缺点：
回旋查找
数据过大时效率慢
### B树 Balance Tree
多路平衡树，在树的基础上对节点进行横向的拉伸
特点：
所有键值分布在整棵树中（索引值和具体的data都在每个节点里）；
任何一个关键字出现且只出现在一个结点中；
搜索有可能在非叶子节点结束（最好情况O(1)就能找到数据）；
在关键字全集内做一次查找，性能逼近二分查找；
规则
每个结点最多有m课子树（m称为阶）
### B+树
也是一种多路搜索树。和B树类似，B+树是B树的变体，但对B树的基础上，做了一些改变
**一颗m阶B+树主要有这些特点**
每个结点至多有m个子女；
**非根节点关键值个数范围： ceiling[m/2]-1 <= k <= m-1**ceiling向上取整
相邻叶子节点是通过指针连起来的，并且是关键字大小排序的
**B+树和B树的主要区别如下：**
B+树内部节点是保存数据的；而B+树内部节点是不保存数据的，只做**索引**作用，它的叶子节点才保存数据。
B+树相邻的叶子节点之间是通过链表指针连起来的，B树却不是。
查找过程中，B树在找到具体的数值以后就结束，而B+树则需要通过索引找到叶子节点中的数据才结束
B树中任何一个关键字出现且只出现在一个结点中，而B+树可以出现多次。
**B+树的插入**
B+树插入都是在叶子结点进行的，就是插入前，需要先找到要插入的叶子结点。
如果被插入关键字的叶子节点，当前含有的关键字数量是小于阶数m，则直接插入。
如果插入关键字后，叶子节点当前含有的关键字数目等于阶数m，则插，该节点开始「分裂」为两个新的节点，一个节点包含⌊m/2⌋ 个关键字，另外一个关键字包含⌈m/2⌉个关键值。（⌊m/2⌋表示向下取整，⌈m/2⌉表示向上取整，如⌈3/2⌉=2）。
分裂后，需要将第⌈m/2⌉的关键字上移到父结点。如果这时候父结点中包含的关键字个数小于m，则插入操作完成。
分裂后，需要将⌈m/2⌉的关键字上移到父结点。如果父结点中包含的关键字个数等于m，则继续分裂父结点。
# 索引
### 作用
提高查询速度
### 定义
将结构化数据中的一部分信息提取出来，重新组织使其变得有一定结构，我们将信息称之为索引
## 1. 索引分类
### 聚集索引
聚集索引是一种索引，该索引中键值的逻辑顺序决定了表中相应的物理顺序。聚集索引也称为聚簇索引（Cluster Index），聚集索引事物理地址连续存放的索引
特点：只能有一个，一般为主键（主键一定是聚集索引，聚集索引并不一定是主键）

什么情况下主键不是聚集索引呢？
答：在建表的时候，并没有加主键，这个时候如果说建立了一个聚集索引，再建立主键，那么这个时候主键就不是聚集索引了
### 非聚集索引
非聚集索引是表中记录的物理顺序和逻辑顺序不同的索引（此外还有空间索引，筛选索引，XML索引）
特点：可以有多个（999）
### 索引说明
每张表上最大的聚集索引为1
每张表上最大的非聚集索引数为999
每个索引最多包含的键列数为16
索引键记录大小最多为900字节
## 2. 索引数据结构
在SQL Server数据库中，索引的存储是以B+树（注意区分和二叉树的区别）
结构来存储，又称索引树，其节点类型为如下两种：
索引节点（Key）;
叶子节点（Key + Value）；
索引节点按照层级关系，有时又分为根节点和中间节点，其本质是一样的，都只包含下一层节点的入口值和入口指针；
叶子节点就不同了，它包含数据，这个数据可能是表中真实的数据行，也有可能是索引列值和行书签，前者对应于聚集索引，后者对应于得聚集索引

B+Tree
数据页：数据库中保存数据的最小单位
索引组织表： 一张表中有聚集索引就是索引组织表
索引表： 一个索引对应一张索引表，索引表中每条数据都对一张数据页

## 3. 索引为什么选择B+树
1、 B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。

2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

3、B+树更便于遍历：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。

4、B+树更适合基于范围的查询：B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。

## 4. 索引设计原则
### 是不是索引越多越好？
肯定不行
索引也是需要空间存储，索引太多意味着占用的空间越多