# 1. 常见的数据结构
### 栈(Stack)
先进后出，后进先出         
Go - 用数组实现栈       
//定义一个新的类型来表达栈，需要一个数组和一个指向最后一个元素的索引       
type stack struct {       
	i int       
	data [10]int       
}       
//注意，Go的数据传递中，是值传递,但是这样不能满足我们的预期。因为一个副本被创建并传递给函数，push和pop处理的都是副本。所以提供指针       
func (s *stack) push(k int) {       
	if s.i +1 > 10 {       
		fmt.Println("I'm full")       
		return       
	}       
	s.data[s.i] = k       
	s.i++       
}       
func (s *stack) pop() int{       
	if s.i -1 < 0 {       
		fmt.Println("I'm hungry")       
		return 0       
	}       
        
	s.i--       
	result := s.data[s.i]       
	s.data[s.i] = 0       
	return result       
}       
### 队列(Queue)
先进先出的一种特殊的线性链表     
### 数组(Array)
查询速度快： 通过地址值与索引可快速定位到数据      
删除效率低： 删除数据后要将每个数据前移     
添加效率极低： 添加位置后每个数据都后移，再添加数据     
### 链表
链表中的数据都是游离存储的，每个元素节点包含元素值与下一元素的地址     
查询速度慢，因为每次查询都要通过head指针依次查询     
添加，删除效率相对较高，因为只需要将指针重新指向新添加进来的元素，其他元素的位置不需要动     
### 二叉树
全名二叉搜索树。存入的数据以第一条数据为基准，小于放左，大于放右     
特点：     
1. 只能有一个根节点，每个节点最多支持两个直接子节点     
2. 节点的度： 节点拥有的子树的个数。节点的度数不大于2，如果度数为0，则称不叶子节点或者终端节点     
缺点：     
虽然二叉树容易提高一些效率，但是面对节点多时，或者树的深度很高时，还是会面临着查找速度慢的情况，而且还很容易出现退化链表的情况（存放数据是有序的时候）。    
### 平衡二叉树 AVL Tree
平衡二叉树是在满足二叉树的情况下，尽可能的让树的度数变低，以提高查询效率     
要求： 任意节点的两个左右子树高度差不超过1，任意节点的左右子树都是一个平衡二叉树     
在底层二叉树的基础上，对进行插入和删除操作时通过特定的操作（如**左旋转和右旋转等**）保持二叉查找树的平衡，从而获得较高查找性能。     
左旋转： 被旋转的节点从左侧上升到父节点     
右旋转： 被旋转的节点从右侧上升到父节点     
https://www.cs.usfca.edu/~galles/visualization/AVLtree.html     
缺点：     
1. 树的深度过高，还是查询慢     
2. 无法解决回旋查找（批量查找）问题     
3. 添加节点效率过低，因为节点旋转有可能会牵一发而动全身     
### 红黑树
自平衡二叉查找树     
每一个节点或者是红色的或者是黑色的，根节点必须是黑色的     
如果某一个节点是红色的，那么它的子节点必须是黑色的（不能出现两个红色项相连情况）     
对每一个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数目的黑色节点     
如果一个节点没有子节点或者父节点，则该节点的相应指针属性值为Null,这些Null视为叶节点，叶节点是黑色     
添加节点：     
添加节点的颜色可以是红色也可以是黑色     
默认使用红色效率高     
**红黑树增删改查效率都比较好**
相对于要求严格的AVL树来说，旋转次数变少，所以对于搜索，插入删除操作多的请况下使用红黑树
缺点：
回旋查找
数据过大时效率慢
### B树 Balance Tree
多路平衡树，在树的基础上对节点进行横向的拉伸
特点：
所有键值分布在整棵树中（索引值和具体的data都在每个节点里）；
任何一个关键字出现且只出现在一个结点中；
搜索有可能在非叶子节点结束（最好情况O(1)就能找到数据）；
在关键字全集内做一次查找，性能逼近二分查找；
规则
每个结点最多有m课子树（m称为阶）
### B+树
