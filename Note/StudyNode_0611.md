# 数据库
### 聚集索引和非聚集索引
聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。             
            
1、聚集索引            
            
聚集索引表记录的排列顺序和索引的排列顺序一致（以InnoDB聚集索引的主键索引来说，叶子节点中存储的就是行数据，行数据在物理储器中的真实地址就是按照主键索引树形成的顺序进行排列的），所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序（因为在真实物理存储器的存储顺序只能有一种，而插入新数据必然会导致主键索引树的变化，主键索引树的顺序发生了改变，叶子节点中存储的行数据也要随之进行改变，就会发生大量的数据移动操作，所以效率会慢）。因为在物理内存中的顺序只能有一种，所以聚集索引在一个表中只能有一个。            
            
2、非聚集索引            
            
非聚集索引制定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致（在逻辑上数据是按顺序排存放的，但是物理上在真实的存储器中是散列存放的），两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。所以如果表的读操作远远多于写操作，那么就可以使用非聚集索引。            
            
3、对比两种索引的例子            
            
**聚集索引**就类似新华字典中的拼音排序索引，都是**按顺序进行**，例如找到字典中的“爱”，就里面顺序执行找到“癌”。而**非聚集索引**则类似于笔画排序，**索引顺序和物理顺序并不是按顺序存放的**。总的来说，**聚集索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块**            
          
4、聚集索引和非聚集索引的区别总结：          
          
**聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个**          
**聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续**          
**聚集索引：物理存储按照索引排序；聚集索引是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序**          
**非聚集索引：物理存储不按照索引排序；非聚集索引则就是普通索引了，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序.**          
**索引是通过B+树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。**                   
          
### 第一：聚集索引的约束是唯一性，是否要求字段也是唯一的呢？ 不要求唯一！
          
分析：如果认为是的朋友，可能是受系统默认设置的影响，一般我们指定一个表的主键，如果这个表之前没有聚集索引，同时建立主键时候没有强制指定使用非聚集索引，SQL会默认在此字段上创建一个聚集索引，而主键都是唯一的，所以理所当然的认为创建聚集索引的字段也需要唯一。          
          
结论：聚集索引**可以创建**在任何一列你想创建的字段上，这是从理论上讲，**实际情况并不能随便指定**，否则在性能上会是恶梦。          
          
### 第二：为什么聚集索引可以创建在任何一列上，如果此表没有主键约束，即有可能存在重复行数据呢？ 虽然和聚集索引的约束规则相悖，实际情况真的可以创建
          
粗一看，这还真是和聚集索引的约束相背，但实际情况真可以创建聚集索引。          
          
分析其原因是：如果未使用 UNIQUE 属性创建聚集索引，数据库引擎将向表自动添加一个四字节 uniqueifier 列。必要时，数据库引擎 将向行自动添加一个 uniqueifier 值，使每个键唯一。此列和列值供内部使用，用户不能查看或访问。          
          
### 第三：是不是聚集索引就一定要比非聚集索引性能优呢? 否
          
如果想查询学分在60-90之间的学生的学分以及姓名，在学分上创建聚集索引是否是最优的呢？          
          
答：否。既然只输出两列，我们可以在学分以及学生姓名上创建联合非聚集索引，此时的索引就形成了覆盖索引，即索引所存储的内容就是最终输出的数据，这种索引在比以学分为聚集索引做查询性能更好。就是说我们用学分去建立非聚集索引，那么搜索出来之后结点中的索引数据区只存有学分的数据，还需要根据叶子节点中数据区中的地址去查询，但是如果直接将要查询的学分字段和姓名字段创建一个联合索引（也是非聚集索引），这样在索引树中查找到数据之后直接就能在节点的索引数据区取得两个索引值，就不用再通过叶子节点中数据区里面的地址再去查询一次了。          
          
### 第四：在MySQL数据库中通过什么描述聚集索引与非聚集索引的？ B+树，根据引擎不同有不同的形式
          
索引是通过B+树的形式进行描述的，我们可以这样区分聚集与非聚集索引的区别：InnoDB中的聚集索引的叶节点就是最终的数据节点，InnoDB中的非聚集索引叶子节点指向的是相应的主键值。而MyISAM中非聚集索引的主键索引树和二级索引树的叶节仍然是索引节点，但它有一个指向最终数据的指针。          
          
在MySQL 5.1之前的版本中，默认的搜索引擎是MyISAM，从MySQL 5.5之后的版本中，默认的搜索引擎变更为InnoDB。          
          
### 第五：在主键是创建聚集索引的表在数据插入上为什么比主键上创建非聚集索引表速度要慢？
          
聚集索引的缺点是对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排，降低了执行速度。插入数据时速度要慢(时间花费在“物理存储的排序”上，也就是首先要找到位置然后插入)。非聚集索引指定了表中记录的逻辑顺序，但记录的物理顺序和索引的顺序不一致，聚集索引和非聚集索引都采用了B+树的结构，但非聚集索引的叶子层并不与实际的数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针的方式。**非聚集索引比聚集索引层次多，添加记录不会引起数据顺序的重组**。这就是为什么主键上创建非聚集索引比主键上创建聚集索引在插入数据时要快的真正原因。          
          
### 聚合函数
          
聚合函数对一组值执行计算并返回单一的值。**除 COUNT 以外，聚合函数忽略空值，如果COUNT函数的应用对象是一个确定列名，并且该列存在空值，此时COUNT仍会忽略空值**。聚合函数经常与 SELECT 语句的 GROUP BY 子句的HAVING一同使用。          
          
所有聚合函数都具有确定性。任何时候用一组给定的输入值调用它们时，都返回相同的值。聚合函数可以应用于查询语句的SELECT中，或者HAVING子句中，但**不可用于WHERE语句中，因为WHERE是对逐条的行记录进行筛选**。          
          
### Count * 和 Count 1的区别

**一般情况下select count(*) 与select count(1)两者返回的结果一致。**
          
但是针对表中主键的有无，情况会有不同。          
          
无主键：count(1)比count(x)快          
          
有主键：count(主键)最快          
          
count(*)与count(1)都包括null统计，而count(column)不包括null统计          
          
### Having
HAVING往往与 GROUP BY 配合使用，为聚合操作指定条件          
### Where 和 Having 有什么区别
          
where 和having之后都是筛选条件，但是有区别的：          
          
1.where在group by前， having在group by 之后          
          
2.聚合函数（avg、sum、max、min、count），不能作为条件放在where之后，但可以放在having之后          
          
3.where子句在查询过程中执行优先级别优先于聚合语句          
          
# .NET
### 项目当中常用的开发模型 WebForm 和 MVC
##### 一、ASP.Net的两种开发模式
1.1 ASP.Net WebForm的开发模式          
          
1.处理流程          
在传统的WebForm模式下，我们请求一个例如http://www.aspnetmvc.com/blog/index.aspx的URL，那么我们的WebForm程序会到网站根目录下去寻找blog目录下的index.aspx文件，然后由index.aspx页面的CodeBehind文件(.CS文件)进行逻辑处理，其中或许也包括到数据库去取出数据(其中的经过怎样的BLL到DAL这里就不谈了)，然后再由index.aspx页面来呈现给用户。          
综上所述，在WebForm模式下：一个URL请求的是在服务器与该URL对应路径上的物理文件(ASPX文件或其他)，然后由该文件来处理这个请求并返回结果给客户端。          
          
2.开发方式          
• 服务器端控件          
• 一般处理程序+Html静态页+Ajax          
• 一般处理程序+Html模板引擎          
          
1.2 ASP.Net MVC的开发模式          
          
1.处理流程          
在ASP.Net MVC中，客户端所请求的URL是被映射到相应的Controller去，然后由**Controller来处理业务逻辑**，或许要**从Model中取数据，然后再由Controller选择合适的View返回给客户端**。再说回前面我们运行的ASP.NET MVC程序访问的http://www.aspnetmvc.com/Home/Index这个URL，它访问的其实是HomeController中的Index这个Action。          
          
2.显著特点                    
• 更加简洁，更加接近原始的“请求-处理-响应”          
• 更加开发、更多的新的特点、社区活跃          
• 不会取代WebForm          
• 底层跟WebForm都是一样的，只是管道上不同的处理而已          
          
##### 二、MVC模式的两种不同解读
MVC 模式两种理解：一种是**表现模式，另外一种是架构模式**。它将应用程序分成三个主要组件即：视图（View）、控制器（Controller）和模型（Model）。现在，我们来看看M-V-C分别代表什么？          
          
M：Model 主要是存储或者是处理数据的组件；Model其实是**实现业务逻辑层对实体类相应数据库操作，如：CRUD。它包括数据、验证规则、数据访问和业务逻辑**等应用程序信息。（补充：ViewModel：视图模型）          
V：View 是**用户接口层组件。主要是将Model中的数据展示给用户。aspx和ascx文件被用来处理视图**的职责；          
C： Controller **处理用户交互，从Model中获取数据并将数据传给指定的View**；          
1.MVC作为架构模式的理解          
          
作为架构模式时，View的职责就是负责展示数据，而Controller则负责获取View传递来的数据，然后调用业务逻辑层处理完成的数据传递给View进行展示。而Model则处理业务逻辑，并把结果返回给Controller。从传统三层架构上来看，**View和Controller都属于UI层**，而**Model则横跨BLL与DAL层**。          
          
2.MVC作为表现模式的理解          
          
3.MVC架构模式综合模型          
          
可以看出，对于MVC的两种不同理解的区别就在于对于Model的理解上：**将Model作为业务模型（BLL、DAL等）还是作为视图模型（ViewModel）**。          
          
##### 三、WebForm vs MVC
**1.WebForm**          
          
优点:           
1.提供了大量的服务器端控件，可以实现快速开发；          
          
2.ViewState回传数据很方便；          
          
3.学习成本低；          
          
缺点:           
1.**封装太强**，虽然学习成本低，很多底层东西让初学者不是很明白；          
          
2.**自定义控制不灵活**，不利于美工和开发人员的配合，往往那些服务器控件处理稍有不慎就会导致出错；          
          
3.**ViewState在页面中的传递会造成大量的流量消耗**；          
          
TIP：有关WebForm的服务器控件和ViewState的详细介绍，不了解的朋友可以阅读另一篇博文《ASP.Net WebForm学习笔记：aspx与服务器控件探秘》。          
          
**MVC**          
          
优点:          
1.很容易将复杂的应用分成Model(ViewModel)、View、Controller三个组件模型，将处理后台逻辑代码与前台展示逻辑进行了**很好的分离，属于松耦合关系**，在大项目应用中，更**易于敏捷开发与测试驱动开发**，有很强的可扩展性；          
          
2.因为没有服务器端控件，所以程序员控制的会更加灵活，页面更加干净，**没有ViewState**；          
          
3.通过**修改路由规则，可以控制生成自定义的url，因此控制生成SEO友好的URL将更加容易**；          
          
4.强类型View实现、Razor视图、Model绑定机制、Model的验证机制，更安全高效；          
          
缺点: 学习成本高，结构复杂，对未变化数据的不必要的频繁访问，也将损害操作性能。          
          
### .NET三层架构

##### 1.三层架构的优势：
适应变化，利于维护：项目往往随市场的变化而发生改变，三层架构通过将各功能模块分离，提高了项目的可维护性和代码的重用性。          
适合协作开发。          
组六趋势，越来越多的企业在开发项目使用三层架构作为基础架构。三层架构在将来会有更大的市场。          
##### 2.三层架构包括哪些层？：
数据访问层（Database access layer），业务逻辑层（business logical layer），表示层（User Interface）          
**数据访问层**：封装了所有与数据库的加互操作。既对数据库的增，删，查，改操作，不做业务逻辑的判断。          
过去使用ADO.NET连接数据库需要编写固定格式的代码，比如打开数据库连接，关闭数据库连接等。在面向对象的课程中，我们在每一个数据库访问层代码中编写重复的ADO.NET代码。那么大家有没有想到重用这些代码呢？这里我们使用了一个封装了ADO.NET方法的类—SqlHeloer类，用来提高数据访问代码的可重用性。          
针对模型层宗的每一个可，数据访问层都有一个对应的数据访问类。比如针对User实体类，有一个对应的UserSevice类，专门处理有关User表的数据。          
##### 3.三层深入理解：          
1.复杂项目不能把SQL语句直接卸载界面里，不模块化，难以维护，应该采用三层结构。先慢慢吸收，然后理解。Wed开发中的三层机构也是同样的结构。还有更复杂的多层架构。          
2.三层的组成          
**界面层UI**          
**数据访问层DAL**          
**业务逻辑层BLL**          
对数据进行操作的代码写在DAL中，一般SQL语句，DAL只有对数据的操作，不能有逻辑判断。          
##### 4.三层实战
1.命名规则：DAL层，一般使用**表明+Service**，例如：EmpService。          
Bll层，一般**表名＋BLL**，例如Emp表在BLL层就命名为EmpBLL          
但是这里注意一点：BLL不是简单的对DAL层的转发，还包含业务逻辑。例如：“未经审核的数据不能删除”这样的业务逻辑就放在BLL中          
2.三层的重点          
**UI层和BLL打交道，不用处理SQL语句**；开发更方便，更不容易出错。一般，**UI层中没有复杂的代码，解耦合，容以改变UI层技术**，如果从Winform改到SAP.NET只需要修改UI就行了，如果MySQL改成Oracle，只需要修改DAL即可。          
Model是在三层中传递数据的，而且Model不属于三层中的任意一层。          
那么各层之间使用Model（实体类的作用是什么呢？）          
表示层中使用实体类          
1.将解析实体对象封装的数据展示给用户。          
2.将用户请求的数据封装到实体对象中。          
业务逻辑层使用实体类          
1.将接受到的实体对象传递到下一层。          
2.根据用户请求对实体对象中的数据进行处理。          
在数据访问层中使用实体类          
1.将接受到的实体对象传递到下一层。          
2.根据用户请求对实体对象中的数据进行处理。          
在数据访问层中使用实体类          
1.将数据库中的数据封装到实体对象中或将多个实体对象封装成集合。          
2.将实体对象中的数据保存到数据库中。          
##### 5.三层的效率
三层一般会比不分层慢，但是为了分工明确，这样的少量的性能下降时可以接受的，很多时候效率不是唯一追求因素。          
### 如何设计一个程序
# Golang
### Go 切片
           
Go 语言切片是对数组的抽象。          
Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片("动态数组")，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大        
make([]T, length, capacity)            
append() 和 copy() 函数          
len() 和 cap() 函数         

# 怎么设计支付接口